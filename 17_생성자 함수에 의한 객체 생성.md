# 17장 생성자 함수에 의한 객체 생성

## 1️⃣ 17.1 Object 생성자 함수
- new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환
- 빈 객체에 프로퍼티 또는 메서드를 추가해 객체를 완성할 수 있음

  ```
  const person = new Object();
  ```

## 2️⃣ 17.2 생성자 함수
#### 📍 생성자 함수
- new 연산자와 함께 호출하여 객체를 생성하는 함수
- 생성자 함수에 의해 생성된 객체를 **인스턴스**라고 함
- 인스턴스를 생성하는 것은 **필수**, 생성된 인스턴스를 초기화하는 것은 옵션

### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점
- 직관적이고 간편하나, 단 하나의 객체만 생성함
- 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적임

### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점
- 객체를 생성하기 위한 템플릿처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성 가능

```
// 생성자 함수
function Circle(radius) {
	this.radius = radius;
    this.getDiameter = function() {
    	return 2 * this.radius;
    };
}

// 인스턴스 생성
const circle1 = new Circle(5);
const circle2 = new Circle(10);
```

#### 📍 this
- 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수
- this 바인딩은 함수 호출 방식에 따라 동적으로 결정됨


| 함수 호출 방식 | this가 가리키는 값 (this 바인딩) | 
|--------|--------|
| 일반 함수로서 호출 | 전역 객체 | 
| 메서드로서 호출 | 메서드를 호출한 객체(마침표 앞의 객체) | 
| 생성자 함수로서 호출 | 생성자 함수가 (미래에) 생성할 인스턴스 | 


### 17.2.3 생성자 함수의 인스턴스 생성 과정
1. 인스턴스 생성과 this 바인딩 : 암묵적으로 빈 객체(인스턴스)가 생성되고 빈 객체가 this에 바인딩됨
2. 인스턴스 초기화 : this에 바인딩되어 있는 인스턴스에 프로퍼티나 메서드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당함
3. 인스턴스 반환 : 생성자 함수 내부에서 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환함. 만약 this가 아닌 다른 객체를 명시적으로 반환하면 this 대신 return 문에 명시된 객체가 반환됨(생성자 함수의 기본 동작을 훼손하는 행동)

### 17.2.4 내부 메서드 [[Call]]과 [[Construct]]
- 함수는 객체이므로 일반 객체와 동일하게 동작함
- 하지만, **일반 객체는 호출할 수 없지만 함수는 호출할 수 있음**
- 따라서, 함수로서 동작하기 위해 함수 객체만을 위한 [[Environment]], [[FormalParamarers]] 등의 내부 슬롯과 [[Call]], [[Construct]] 같은 내부 메서드를 추가로 가지고 있음
- 함수가 일반 함수로서 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출됨 => **_callable_**
- new 연산자와 함께 생성자 함수로서 호출되면 [[Construct]]가 호출됨 => **_constructor_**

🔥 **모든 함수 각체는 callable 이지만, 모든 함수 객체가 constructor인 것은 아니다**

### 17.2.5 constructor와 non-constructor의 구분
- constructor : 함수 선언문, 함수 표현식, 클래스
- non-constructor : 메서드, 화살표 함수 => 생성자 함수로서 호출 시 내부 메서드인 [[Construct]]가 존재하지 않아 에러가 발생함

### 17.2.6 new 연산자
- new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작함
- 단 new 연산자와 함께 호출하는 함수는 constructor이어야 함
- new 연산자 없이 생성자 함수를 호출하면 일반 함수로 호출됨

```
// 생성자 함수로서 정의하지 않은 일반 함수
function add(x,y) {
	return x + y;
}

// 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출
let inst = new add();

// 함수가 객체를 반화하지 않으므로 반환문이 무시됨. 따라서 빈 객체가 생성되어 반환됨
console.log(inst); // {}

// 객체를 반환하는 일반 함수
function createUser(name, role) {
	return {name, role};
}

// 일반 함수를 new 연산자와 함께 호출
inst = new createUser('Lee', 'admin');

// 함수가 생성한 객체를 반환
console.log(inst); // {name : 'Lee', role : 'admin'};
```

### 17.2.7 new.target
- 생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 ES6에서 지원하는 것
- this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 **메타 프로퍼티**라고 부름
- new 연산자와 함께 생성된 함수로서 호출되면 함수 내부의 new.target은 **함수 자신**을 가리킴
- new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined
- **따라서 함수 내부에서 new.target을 사용하여 new 연산자와 함께 생성자 함수로서 호출되었는지 확인 가능함**

```
function Circle(radius) {
	if(!new.target) { // new 연산자로 호출되지 않았으면
    	return new Circle(radius); // new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스 반환함
    }
}
```

#### 📍 스코프 세이브 생성자 패턴
- new.target은 IE에서 지원하지 않으므로 스코프 세이프 생성자 패턴을 사용할 수 있음
- this를 확인해 만약 this가 전역 객체 window를 가리키는지 확인함
```
function Circle(radius) {
	if(!(this instanceof Cicle)) { // new 연산자로 호출되지 않았으면
    	return new Circle(radius); // new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스 반환함
    }
}
```

#### 📍 빌트인 생성자 함수
- 대부분의 빌트인 생성자 함수는 new 연산자와 함께 호출되었는지를 확인 후 적절한 값을 반환함
- Object, Function 생성자 함수를 new 연산자 없이 호출해도 new 연산자와 함께 호출했을 때와 동일하게 동작함
- String, Number, Boolean 생성자는 new연산자 없이 호출하면 문자열, 숫자, 불리언 값을 반환함. 이를 통해 데이터를 타입 반환하기도 함
